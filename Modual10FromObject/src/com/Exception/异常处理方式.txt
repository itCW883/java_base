异常处理方式:
    1:虚拟机jvm的默认处理方式:
        ①:把异常的名称,原因,出现的位置等信息输出到控制台;以红色字体
        ②:程序停止;异常后的代码不在运行

    2:throws:   格式 throws 异常[在方法参数和方法体之间写]
            意义:处理异常(将异常向上throw)
            无脑throws会导致一个功能出现问题;其他功能也不能使用

          多异常处理:
                格式:throws 异常1,异常2...,异常n
            若异常间有子父类继承关系,可以直接写父类异常
            不知道异常之间是否有子父类继承关系可以直接写Exception
throws:写在方法定义处,表示声明一个异常;告诉调用者;使用本方法可能会有哪些异常
throw: 写在方法内,结束方法,手动抛出异常对象,交给执行者;方法中下面的代码不在执行

    3:捕获异常
        try ... catch:
            格式:
                  try{
                          可能出现异常的代码
                  }catch(异常类名 自定义的对象名){
                        处理异常的代码(可以直接打印在控制台上)
                        [把异常信息保存到日志文件中]
                  }
    try ... catch:出现异常功能间不会相互影响
    若try ... catch未抓到出现的异常;编译时会报错依然交由jvm处理;依然会影响后续代码运行(可以抓父类Exception,但一般使用精准打击)
    若异常间有子父类继承关系;catch捕获异常时,父类异常一定要在子类异常下面
    jdk7以后:若有多个异常的处理方案是一样的;可以使用catch异常捕获多个异常中间用 | 隔开(不能写||因为双或有截断特性)
    try中出现问题;try中出现异常的代码下面的代码就不会执行了

    特点:出现异常,让可以让异常后的代码继续运行
            try ... catch 多个异常:
                格式:
                    try{
                          可能出现异常的代码
                    }
                    catch(异常1(异常的类名) 自定义的对象名){
                     处理异常的代码(可以直接打印在控制台上)
                     [把异常信息保存到日志文件中]
                     }
                     catch(异常2(异常的类名) 自定义的对象名){
                      }
                      finally{
                      }
            若catch间有子父类继承关系可以直接catch父类异常,若想子父类异常均catch则需要现catch子类,再catch父类

    finally:
       意义:无论是否触发异常都会执行的代码
       特殊情况:如果之前执行了System.exit(0)[代表终止当前正在执行的虚拟机];
       格式:
            finally{        }
       执行顺序: try-->finally-->catch