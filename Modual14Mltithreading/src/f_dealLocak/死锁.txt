死锁:
    两个或两个以上线程在执行过程中由于竞争同步锁而产生的阻塞现象;若没有外力作用几句无法继续下去
    死锁一般容易出现在同步代码块的嵌套


线程状态:
       1: NEW
        线程刚被创建,但尚未启动的线程处于此状态。

       2:RUNNABLE
        在Java虚拟机中执行的线程处于此状态。

       3: BLOCKED
        锁阻;塞等待监视器锁定的线程处于此状态。

       4: WAITING
        无限等待
        正在等待另一个线程执行特定动作的线程处于此状态。
        调用:wait(空参)就会无限等待
        wait(空参):
            线程进入无限等待状态,会释放锁;
            需要其他线程调用notify():一次唤醒只能一条等待的线程;(多条线程等待一次随机的唤醒一条线程)
            或者notifyAll()方法:一次唤醒所有的等待线程
            被唤醒后需要和其他线程抢锁(抢到继续执行,未抢到所锁阻塞)
        notify():
            一次唤醒(随机的)一条等待的线程
        notifyAll()方法:
            一次唤醒所有的等待线程
①:wait和notify方法都需要锁对象调用,其他对象不能调用;
因此两个方法均需要用于同步代码块中或者同步方法中
同步代码块和同步方法才有锁对象
②:两个方法的调用必须是同一个锁对象(相当于同一把锁将多条线程分到一组,这样notify才知道唤醒的是同组的线程)

      5:  TIMED_WAITING
        记时等待(sleep()就属于记时等待)
        正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
            sleep():线程睡眠;在睡眠中线程是不会释放锁的,此时其他线程无法抢到锁,设置时间一旦超时就会醒来,继续执行
            wait():线程等待;会释放锁,在这段时间中其他线程就可能会抢到锁,如果在等待过程中被唤醒,或者时间超时,
            线程醒来后可能会不会继续执行(需要和其他线程抢锁,抢到继续执行,抢不到锁阻塞)

      6:  TERMINATED
        被终止
        run方法正常退出,或者因为为被捕获异常终止run方法
        已退出的线程处于此状态。
线程的六种状态间可以互相转换